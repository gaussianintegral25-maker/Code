import matplotlib.pyplot as plt
import datetime
import solarsystem
import numpy
now    = datetime.datetime.utcnow()
now    = datetime.datetime.now(datetime.timezone.utc)
year   = now.year
month  = now.month
day    = now.day
hour   = now.hour
minute = now.minute
UT = 0
dst = 0

import math

import tkinter as tk
from tkinter import ttk
import numpy as np
root = tk.Tk()
root.title("Newton Kayode's NASA Hackathon Submission")

label = tk.Label(root, text="Low Earth Orbit And Beyond!!!")
label.pack(pady=20)

label = tk.Label(root, text="Planet you want to go to")
label.pack(pady=11)
entry = tk.Entry(root)

entry_widget = tk.Entry(root, width=50)
entry_widget.pack(pady=10)

label2 = tk.Label(root, text="How many individuals: ")
label2.pack(pady=11)
entry2 = tk.Entry(root)

entry_widget = tk.Entry(root, width=50)
entry_widget.pack(pady=10)

submit_button = tk.Button(root, text="Submit", command=get_text_input)
submit_button.pack()
group=['venus','mars']

    
#degree_sign= u'\N{DEGREE SIGN}'

def normalize(degrees):  
    """
    set degrees always between 0 - 360
    
    Args:
        degrees (float): degrees to be adjusted
        
    Returns:
        float: degrees between 0-360
        
    """
    return degrees % 360

    

def spherical2rectangular(RA, Decl, r):
    """Transform spherical to rectangular projection.
    
    From spherical (RA,Decl) coordinates system to rectangular(x,y,z) or 
    by replacing RA with longitude and Decl with latitude we can tranform 
    ecliptic coordinates to horizontal (azimuth,altitude).
    
    Args:
        RA: Right Ascension.
        Decl: Declination.
        r: Distance in astronomical units.
   
    Returns:
        tuple: x, y, z rectangular coordinate system. 
        
    """
    
    RA = math.radians(RA)
    Decl = math.radians(Decl)
    x = r * math.cos(RA) * math.cos(Decl)
    y = r * math.sin(RA) * math.cos(Decl)
    z = r * math.sin(Decl)
    
    return (x, y, z)


def rectangular2spherical(x, y, z):
    """Transform rectangular to spherical projection.
    
    From rectangular(x,y,z) coordinates system to spherical (RA,Decl, r) or 
    by replacing x with azimuth and y with altitude we can tranform 
    horizontal coordinates to ecliptic (longitude, latitude).
    
    Args:
        x: value on x axis of a rectangular projection.
        y: value on y axis of a rectangular projection.
        z: value on z axis of a rectangular projection.
   
    Returns:
        tuple: RA, Decl, r spherical coordinate system. 
        
    """
    
    r    = math.sqrt( x*x + y*y + z*z )
    RA   = math.atan2( y, x )
#    Decl = math.asin( z / r ) 
    Decl = math.atan2( z, math.sqrt( x*x + y*y ) )
    
    RA = normalize(math.degrees(RA))
    Decl = (math.degrees(Decl))
    return (RA, Decl, r)
    


def ecliptic2equatorial(xeclip, yeclip, zeclip, oblecl):
    """Transform ecliptic to equatorial projection.
    
    Args:
        xeclip: value on x axis of ecliptic plane.
        yeclip: value on y axis of ecliptic plane.
        zeclip: value on z axis of ecliptic plane.
        oblecl: obliquity of the ecliptic, approximately 23.4 degrees for earth
   
    Returns:
        tuple: x, y, z equatorial projection 
        
    """
#    oblecl = math.radians(oblecl)
    
    xequat = xeclip
    yequat = yeclip * math.cos(oblecl) - zeclip * math.sin(oblecl)
    zequat = yeclip * math.sin(oblecl) + zeclip * math.cos(oblecl)
    
    return (xequat, yequat, zequat)



def equatorial2ecliptic(xequat, yequat, zequat, oblecl):
    """Transform equatorial to ecliptic projection.
    
    Args:
        xequat: value on x axis of equatorial plane
        yequat: value on y axis of equatorial plane
        zequat: value on z axis of equatorial plane
        oblecl: obliquity of the ecliptic, approximately 23.4 degrees for earth
   
    Returns:
        tuple: x, y, z ecliptic projection 
        
    """
    
#    oblecl = math.radians(oblecl)
    xeclip = xequat
    yeclip = yequat * math.cos(-oblecl) - zequat * math.sin(-oblecl)
    zeclip = yequat * math.sin(-oblecl) + zequat * math.cos(-oblecl)
    return (xeclip, yeclip, zeclip)
    


def spherical_ecliptic2equatorial(long, lat, distance, oblecl):
    """Transform eclipitc to spherical projection for given obliquity.
    
    From spherical (RA, Decl, distance) coordinates system to 
    eclipitc(long, lat, distance).
    
    Args:
        long: Longitude.
        last: Latitude.
        distance: Distance in astronomical units.
        oblecl: obliquity (axial tilt).
            
    Returns:
        tuple: RA, Decl, distance spherical coordinate system. 
        
    """
    
    b = spherical2rectangular(long,lat,distance)
    c = ecliptic2equatorial(b[0],b[1],b[2], oblecl)
    return rectangular2spherical(c[0],c[1],c[2])


def spherical_equatorial2ecliptic(RA, Decl, distance, oblecl):
    """Transform spherical to eclipitc projection for given obliquity.
    
    From spherical (RA, Decl, distance) coordinates system to 
    eclipitc(long, lat, distance).
    
    Args:
        RA: Right Ascension.
        Decl: Declination.
        distance: Distance in astronomical units.
        oblecl: obliquity (axial tilt).
            
    Returns:
        tuple: long, lat, distance eclipitc coordinate system. 
        
    """
    
    b = spherical2rectangular(RA, Decl,distance)
    c = equatorial2ecliptic(b[0],b[1],b[2], oblecl)
    return rectangular2spherical(c[0],c[1],c[2])


def demical2clock(demicaltime):
    """
    Convert demical time view to Hours, Minutes and Seconds.
    
    Args:
        demicaltime (float): time to be converted.
        
    Returns:
        str: one string representation in hours, minutes format.
        
    """ 
    h = int(demicaltime)
    m = int((demicaltime - h) * 60)
    s = int(((demicaltime-h)*60 - m ) * 60)
    h=str(h)
    m=str(m)
    s=str(s)
    if len(h)==1: h = '0' + h
    if len(m)==1: m = '0' + m
    if len(s)==1: s = '0' + s
    res = h + ':'+ m + ':'+ s
    return res


def demical2arcs(num):
    """
    Convert Demical view to Degrees and minutes.
    
    Args:
        num (float): degrees to be converted.
        
    Returns:
        str: one string representation in degrees and minutes format.
        
    """
#    return(str(int(num))+u"\u00b0 "+str(round(abs(num - int(num))*60,2))+"'")
    return(str(int(num))+"Â° "+str(round(abs(num - int(num))*60,2))+"'")

#def degrees2hours(degrees):
#    """
#    Convert degrees to string representation of hours, minutes and seconds.
#    
#    Args:
#        degrees (float): degrees to be converted.
#        
#    Returns:
#        str: one string representation in hours, minutes and seconds format.
#        
#    """    
#    h=degrees//15
#    r=(degrees%15)*4
#    m=int(r)
#    s=int((r-m)*60)
#    return (str(h)+'h '+str(m)+'m '+str(s)+'s')

def demical2hms(degrees):
    """
    Convert degrees to string representation of hours, minutes and seconds.
    
    Args:
        degrees (float): degrees to be converted.
        
    Returns:
        str: one string representation in hours, minutes and seconds format.
        
    """   
    
    h = int(degrees/15)
    m = int((degrees/15 - h) * 60)
    s = int(((degrees/15-h)*60 - m ) * 60)
    h=str(h)
    m=str(m)
    s=str(s)
    if len(h)==1: h =  h
    if len(m)==1: m =  m
    if len(s)==1: s =  s
    res = h + 'h '+ m + 'm '+ s +'s'
    return res


def Planet_Sun(M, e, a, N, w, i):
    """
    Helper Function. From planet's trajectory elements to position around sun
        
    Returns:
        tuple: position elements
        
    """
    M2=math.radians(M)
    E0=M + (180/math.pi)*e*math.sin(M2)*(1+e*math.cos(M2))
    E0=normalize(E0) 
    E02=math.radians(E0)
    E1=E0 - (E0 - (180/math.pi)*e*math.sin(E02)-M)/(1-e*math.cos(E02))
    E1=normalize(E1) 
    E=math.radians(E1)
    x=a*(math.cos(E)-e)
    y=a*(math.sqrt(1 - e*e))*math.sin(E)

    r=math.sqrt(x*x+y*y)
    v=math.atan2(y, x)
    v=normalize(math.degrees(v))

    xeclip=r*(math.cos(math.radians(N))*math.cos(math.radians(v+w)) - math.sin(math.radians(N))*math.sin(math.radians(v+w))*math.cos(math.radians(i)))
    yeclip=r*(math.sin(math.radians(N))*math.cos(math.radians(v+w)) + math.cos(math.radians(N))*math.sin(math.radians(v+w))*math.cos(math.radians(i)))
    zeclip=r*math.sin(math.radians(v+w))*math.sin(math.radians(i)) 
    long2 = math.atan2( yeclip, xeclip )
    long2=normalize(math.degrees(long2))
    lat2 = math.atan2( zeclip, math.sqrt( xeclip*xeclip +yeclip*yeclip ) )
    lat2=math.degrees(lat2)
    return (xeclip,yeclip,zeclip, long2, lat2, r)


def sun2planet(xeclip, yeclip, zeclip, x, y, z):
    """
    Helper Function. From Hliocentric to Geocentric position
        
    Returns:
        tuple: geocentric view of object.
        
    """
    x_geoc=(x+xeclip)
    y_geoc=(y+yeclip)
    z_geoc=(z+zeclip)

    return rectangular2spherical(x_geoc, y_geoc, z_geoc)
#    t = ecliptic2equatorial(x_geoc, y_geoc, z_geoc, 23.4)
#    return rectangular2spherical(t[0],t[1],t[2])

import math
from .functions import normalize, Planet_Sun, rectangular2spherical

class Heliocentric:
    """Import date data outputs planets positions around Sun.
    
    Args:
        year (int): Year (4 digits) ex. 2020
        month (int): Month (1-12)
        day (int): Day (1-31)
        hour (int): Hour (0-23)
        minute (int): Minute (0-60)
        UT: Time Zone (deviation from UT, -12:+14), ex. for Greece (GMT + 2) 
            enter UT = 2
        dst (int): daylight saving time (0 or 1). Wheather dst is applied at 
                   given time and place
        view: desired output format. Should be one of: horizontal (long in 
              degrees, lat in degrees, distance in AU) or 
              rectangular (x, y, z, all in AU).
              Default: horizontal.
 
    """
    
    def __init__(self, year, month, day, hour, minute, UT=0, dst=0, 
                 view='horizontal'): 

        self.view = view
        pr=0.
        if (dst==1) : pr=1/24. 
        JDN=( (367*(year) - math.floor(7*(year + math.floor((month+9 )/12))/4))
        + math.floor(275*(month)/9) + (day + 1721013.5 - UT/24. ) )
        JD= (JDN + (hour)/24. + minute/1440. - pr)
        j2000= 2451543.5
        d= JD - j2000
        self.d = d
        
        # sun' s trajectory elements
        w=282.9404 + 4.70935E-5 * d      
#        a=1
        e=(0.016709 - (1.151E-9  * d))   
        M=356.047 + 0.9856002585 * d   
        M=normalize(M)
        L=w+M   
        L=normalize(L)
        oblecl=23.4393 - 3.563E-7 * d
        M2=M
        M=math.radians(M)
        E=M2 + (180/math.pi)*e*math.sin(M)*(1+e*math.cos(M))
        E=math.radians(E)
        x=math.cos(E)-e 
        y=math.sin(E)*math.sqrt(1-e*e)
        
        r=math.sqrt(x*x + y*y) 

        
        v=math.atan2(y,x)  
        v=math.degrees(v)
        lon=(v+w)    
        lon=normalize(lon)
        lon=math.radians(lon) 
        x2=r * math.cos(lon) 
        y2=r * math.sin(lon)
        z2=0
        
        
        xequat = x2   
        oblecl= math.radians(oblecl)
        self.oblecl = oblecl
        yequat = (y2*math.cos(oblecl) + z2 * math.sin(oblecl))
        zequat = (y2*math.sin(oblecl) + z2 * math.cos(oblecl))
       
        
        RA=math.atan2(yequat, xequat)
        RA=math.degrees(RA)
        RA=normalize(RA)
        Decl=math.atan2(zequat, math.sqrt(xequat*xequat +yequat*yequat))
        Decl=math.degrees(Decl)

        self.x=normalize(math.degrees(x))
        self.y=normalize(math.degrees(y))
        self.r=r
        self.x2=x2
        self.y2=y2
        self.z2=z2
        self.lon = normalize(-math.degrees(lon))
        lat = math.atan2( z2, math.sqrt( x2**2 + y2**2 ) )
        lat=normalize(math.degrees(lat))
        self.lat=lat
        
        self.earthX = -1*x2
        self.earthY = -1*y2
        self.earthZ = z2 # =0
        
        

    def planetnames(self):
        """Names of solar system objects used. 
        
        Returns:
            list: A list of solar system objects.
            
        """  
        return( ["Mercury","Venus","Earth","Mars","Jupiter","Saturn","Uranus",
                "Neptune","Pluto","Ceres","Chiron","Eris"])

    

    def planets(self):
        """Main method which returns a dictionary of Heliocentric positions.
        
        Returns:
            dictionary: Planet positions around sun: Dictionary of tuples. Each
            row represents a planet and each column the position of that planet.
            
        """
        
        # Planets trajectory elements
        #Ermis
        N_er=48.3313 + 3.24587E-5 *self.d
        i_er=7.0047 +5.00E-8 *self.d
        w_er=29.1241 + 1.01444E-5 *self.d
        a_er=0.387098
        e_er=0.205635 + 5.59E-10 *self.d
        M_er=168.6562 + 4.0923344368 *self.d
        
        M_er=normalize(M_er)
        
        #Afroditi
        N_af=76.6799 + 2.46590E-5 *self.d
        i_af=3.3946 +2.75E-8 *self.d
        w_af=54.8910 + 1.38374E-5 *self.d
        a_af=0.723330
        e_af=0.006773 - 1.30E-9 *self.d
        M_af=48.0052 + 1.6021302244 *self.d
        
        M_af=normalize(M_af)
        
        #Aris
        N_ar=49.5574 + 2.11081E-5 *self.d
        i_ar=1.8497 - 1.78E-8 *self.d
        w_ar=286.5016 + 2.92961E-5 *self.d
        a_ar=1.523688
        e_ar=0.093405 + 2.51E-9 *self.d
        M_ar=18.6021 + 0.5240207766 *self.d
        
        M_ar=normalize(M_ar)
        
        #Dias
        N_di=100.4542 + 2.76854E-5 *self.d
        i_di=1.3030 - 1.557E-7 *self.d
        w_di=273.8777 + 1.6450E-5 *self.d
        a_di=5.20256
        e_di=0.048498 + 4.469E-9 *self.d
        M_di=19.8950 + 0.0830853001 *self.d
        
        M_di=normalize(M_di)
        
        #Kronos
        N_kr=113.6634 + 2.38980E-5 *self.d
        i_kr=2.4886 - 1.081E-7 *self.d
        w_kr=339.3939 + 2.97661E-5 *self.d
        a_kr=9.55475
        e_kr=0.055546 - 9.499E-9 *self.d
        M_kr=316.9670 + 0.0334442282 *self.d
        
        M_kr=normalize(M_kr)
        
        #Ouranos
        N_ou=74.0005 + 1.3978E-5 *self.d
        i_ou=0.7733 + 1.9E-8 *self.d
        w_ou=96.6612 + 3.0565E-5 *self.d
        a_ou=19.18171 - 1.55E-8 *self.d
        e_ou=0.047318 + 7.45E-9 *self.d
        M_ou=142.5905 + 0.011725806 *self.d
        
        M_ou=normalize(M_ou)
        
        #Poseidonas
        N_po=131.7806 + 3.0173E-5 *self.d
        i_po=1.7700 - 2.55E-7 *self.d
        w_po=272.8461 - 6.027E-6 *self.d
        a_po=30.05826 + 3.313E-8 *self.d
        e_po=0.008606 + 2.15E-9 *self.d
        M_po=260.2471 + 0.005995147 *self.d
        
        M_po=normalize(M_po)
          
        
        #D CERES epoch 2455400.5 2010-jul-23.0   j2000= 2451543.5
        ddd = self.d + 2451543.5 - 2455400.5
        
        N_ce=80.39319901972638  + 1.1593E-5 *ddd
        i_ce=10.58682160714853 - 2.2048E-6*ddd
        w_ce=72.58981198193074  + 1.84E-5*ddd
        a_ce=2.765348506018043 
        e_ce=0.07913825487621974 + 1.8987E-8*ddd
        M_ce=113.4104433863731   + 0.21408169952325  * ddd 
        
        M_ce=normalize(M_ce)
        
        #A CHIRON epoch  2456400.5 2013-apr-18.0   j2000= 2451543.5
        dddd = self.d + 2451543.5 - 2456400.5
        
        N_ch=209.3557401732507 	 
        i_ch=6.929449422368333 	
        w_ch=339.3298742575888 	
        a_ch=13.6532230321495 
        e_ch=0.3803659797957286  
        M_ch=122.8444574834622  +  0.01953670401251872 * dddd   
        
        M_ch=normalize(M_ch)
        
        #A ERIS epoch  2456400.5 2013-apr-18.0   j2000= 2451543.5
        ddddd= self.d + 2451543.5 - 2456400.5
        
        N_pe=36.0308972598494  
        i_pe=43.88534676566927 
        w_pe=150.8002573158863 
        a_pe=67.95784302407351 
        e_pe=0.4370835020505101 
        M_pe=203.2157808586589 +  0.001759319413340421 * ddddd   
        
        M_pe=normalize(M_pe)
        

        #Ermis
        xereclip,yereclip,zereclip, long2_er, lat2_er, r_er = Planet_Sun(M_er, 
                                            e_er, a_er, N_er, w_er, i_er)
        
        #Afroditi
        xafeclip,yafeclip,zafeclip, long2_af, lat2_af, r_af = Planet_Sun(M_af, 
                                            e_af, a_af, N_af, w_af, i_af)
        
        #Aris
        xareclip,yareclip,zareclip, long2_ar, lat2_ar, r_ar = Planet_Sun(M_ar, 
                                            e_ar, a_ar, N_ar, w_ar, i_ar)
        
        
        #Dias
        xdieclip,ydieclip,zdieclip, long2_di, lat2_di, r_di = Planet_Sun(M_di, 
                                            e_di, a_di, N_di, w_di, i_di)
        
        #Kronos
        xkreclip,ykreclip,zkreclip, long2_kr, lat2_kr, r_kr = Planet_Sun(M_kr, 
                                            e_kr, a_kr, N_kr, w_kr, i_kr)
        
        #Ouranos
        xoueclip,youeclip,zoueclip, long2_ou, lat2_ou, r_ou = Planet_Sun(M_ou, 
                                            e_ou, a_ou, N_ou, w_ou, i_ou)
        
        #Poseidonas
        xpoeclip,ypoeclip,zpoeclip, long2_po, lat2_po, r_po = Planet_Sun(M_po, 
                                            e_po, a_po, N_po, w_po, i_po)
        
        
        #Ceres
        xceeclip,yceeclip,zceeclip, long2_ce, lat2_ce, r_ce = Planet_Sun(M_ce, 
                                            e_ce, a_ce, N_ce, w_ce, i_ce)
        
        #Chiron
        xcheclip,ycheclip,zcheclip, long2_ch, lat2_ch, r_ch = Planet_Sun(M_ch, 
                                            e_ch, a_ch, N_ch, w_ch, i_ch)
        
        #Eris
        xpeeclip,ypeeclip,zpeeclip, long2_pe, lat2_pe, r_pe = Planet_Sun(M_pe, 
                                            e_pe, a_pe, N_pe, w_pe, i_pe)
        
        #ploutonas
        S_pl  = math.radians(  50.03  +  0.033459652 *  self.d)
        P_pl  = math.radians( 238.95  +  0.003968789 *  self.d)
        
        long2_pl = (238.9508  +  0.00400703 * self.d - 19.799 * math.sin(P_pl)
                     + 19.848 * math.cos(P_pl) + 0.897 * math.sin(2*P_pl)
               - 4.956 * math.cos(2*P_pl) + 0.610 * math.sin(3*P_pl)
               + 1.211 * math.cos(3*P_pl) - 0.341 * math.sin(4*P_pl)
               - 0.190 * math.cos(4*P_pl) + 0.128 * math.sin(5*P_pl)
               - 0.034 * math.cos(5*P_pl) - 0.038 * math.sin(6*P_pl)
               + 0.031 * math.cos(6*P_pl) + 0.020 * math.sin(S_pl - P_pl) 
               - 0.010 * math.cos(S_pl - P_pl) )
        lat2_pl = ( -3.9082 - 5.453 * math.sin(P_pl) - 14.975 * math.cos(P_pl)
                      + 3.527 * math.sin(2*P_pl) + 1.673 * math.cos(2*P_pl)
                      - 1.051 * math.sin(3*P_pl) + 0.328 * math.cos(3*P_pl)
                      + 0.179 * math.sin(4*P_pl) - 0.292 * math.cos(4*P_pl)
                      + 0.019 * math.sin(5*P_pl) + 0.100 * math.cos(5*P_pl)
                      - 0.031 * math.sin(6*P_pl) - 0.026 * math.cos(6*P_pl)
                      + 0.011 * math.cos(S_pl - P_pl) )
        r_pl = ( 40.72 + 6.68 * math.sin(P_pl) + 6.90 * math.cos(P_pl)
                      - 1.18 * math.sin(2*P_pl) - 0.03 * math.cos(2*P_pl)
                      + 0.15 * math.sin(3*P_pl) - 0.14 * math.cos(3*P_pl))
        
        long2_pl=math.radians(long2_pl)
        lat2_pl=math.radians(lat2_pl)
        x_pl = r_pl * math.cos(long2_pl) * math.cos(lat2_pl) #eclip
        y_pl = r_pl * math.sin(long2_pl) * math.cos(lat2_pl)
        z_pl = r_pl * math.sin(lat2_pl)
        
 
    
        #Perturbations 
        M_di=normalize(M_di)
        M_kr=normalize(M_kr)
        M_ou=normalize(M_ou)
        
        #add to Jupiter long
        di_diat1=-0.332*math.sin(math.radians(2*M_di - 5 * M_kr - 67.6))
        di_diat2=-0.056*math.sin(math.radians(2*M_di - 2 * M_kr +21))
        di_diat3=0.042*math.sin(math.radians(3*M_di - 5 * M_kr +21))
        di_diat4=-0.036*math.sin(math.radians(M_di - 2 * M_kr))
        di_diat5=0.022*math.cos(math.radians(M_di - M_kr))
        di_diat6=0.023*math.sin(math.radians(2*M_di - 3 * M_kr + 52))
        di_diat7=-0.016*math.sin(math.radians(M_di - 5 * M_kr - 69))
        
        #add to Saturn long
        kr_diat1=0.812*math.sin(math.radians(2*M_di - 5 * M_kr - 67.6))
        kr_diat2=-0.229*math.cos(math.radians(2*M_di - 4 * M_kr -2))
        kr_diat3=0.119*math.sin(math.radians(M_di - 2 * M_kr - 3))
        kr_diat4=0.046*math.sin(math.radians(2*M_di - 6 * M_kr - 69))
        kr_diat5=0.014*math.sin(math.radians(M_di - 3* M_kr + 32))
        #add to Saturn lat
        kr_diat6=-0.02*math.cos(math.radians(2*M_di - 4 * M_kr - 2))
        kr_diat7=0.018*math.sin(math.radians(2*M_di - 6 * M_kr - 49))
       
        #add to Uranus long
        ou_diat1=0.04*math.sin(math.radians(M_kr - 2 * M_ou + 6))
        ou_diat2=0.035*math.sin(math.radians(M_kr - 3 * M_ou + 33))
        ou_diat3=-0.015*math.sin(math.radians(M_di - M_ou +20))
        
        diataraxes_long_di=(di_diat1 + di_diat2 + di_diat3 + di_diat4 + 
                            di_diat5 + di_diat6 + di_diat7)
        diataraxes_long_kr=(kr_diat1 + kr_diat2 + kr_diat3 + kr_diat4 
                            + kr_diat5)
        diataraxes_lat_kr=(kr_diat6 + kr_diat7)
        diataraxes_long_ou=(ou_diat1 + ou_diat2 + ou_diat3)
        
        #Corrected coordinates for the three planets
        long2_di=long2_di + diataraxes_long_di
        long2_kr=long2_kr + diataraxes_long_kr
        lat2_kr=lat2_kr + diataraxes_lat_kr
        long2_ou=long2_ou + diataraxes_long_ou
        
        long2_di=(math.radians(long2_di))
        lat2_di=(math.radians(lat2_di))
        long2_kr=(math.radians(long2_kr))
        lat2_kr=(math.radians(lat2_kr))
        long2_ou=(math.radians(long2_ou)) 
        lat2_ou=(math.radians(lat2_ou)) 
        
        #Recompute positions of three planets
        xdieclip = r_di * math.cos(long2_di) * math.cos(lat2_di)
        ydieclip = r_di * math.sin(long2_di) * math.cos(lat2_di) 
        zdieclip = r_di * math.sin(lat2_di)
        xkreclip = r_kr * math.cos(long2_kr) * math.cos(lat2_kr)
        ykreclip = r_kr * math.sin(long2_kr) * math.cos(lat2_kr) 
        zkreclip = r_kr * math.sin(lat2_kr)
        xoueclip = r_ou * math.cos(long2_ou) * math.cos(lat2_ou)
        youeclip = r_ou * math.sin(long2_ou) * math.cos(lat2_ou) 
        zoueclip = r_ou * math.sin(lat2_ou)  
        
        
        long2_di=normalize(math.degrees(long2_di))
        lat2_di=normalize(math.degrees(lat2_di))
        long2_kr=normalize(math.degrees(long2_kr))
        lat2_kr=normalize(math.degrees(lat2_kr))
        long2_ou=normalize(math.degrees(long2_ou)) 
        lat2_ou=normalize(math.degrees(lat2_ou)) 
        
        long2_pl=normalize(math.degrees(long2_pl))
        lat2_pl=normalize(math.degrees(lat2_pl))
        
        
        long_earth, lat_earth, dist_earth = rectangular2spherical(self.earthX, self.earthY, self.earthZ)
        
        if self.view == 'horizontal':
            return {
                    'Mercury':(long2_er, lat2_er, r_er),
                    'Venus'  :(long2_af, lat2_af, r_af),
                    'Earth'  :(normalize(long_earth), lat_earth, dist_earth),
#                    'Earth'  :(self.lon, self.lat, self.r),
                    'Mars'   :(long2_ar, lat2_ar, r_ar),
                    'Jupiter':(long2_di, lat2_di, r_di),
                    'Saturn' :(long2_kr, lat2_kr, r_kr),
                    'Uranus' :(long2_ou, lat2_ou, r_ou),
                    'Neptune':(long2_po, lat2_po, r_po),
                    'Pluto'  :(long2_pl, lat2_pl, r_pl),
                    'Ceres'  :(long2_ce, lat2_ce, r_ce),
                    'Chiron' :(long2_ch, lat2_ch, r_ch),
                    'Eris'   :(long2_pe, lat2_pe, r_pe)
                    }
            
        elif self.view == 'rectangular':     
            return {
                    'Mercury':(xereclip,yereclip,zereclip),
                    'Venus'  :(xafeclip,yafeclip,zafeclip),
                    'Earth'  :(self.earthX, self.earthY, self.earthZ),
                    'Mars'   :(xareclip,yareclip,zareclip),
                    'Jupiter':(xdieclip,ydieclip,zdieclip),
                    'Saturn' :(xkreclip,ykreclip,zkreclip),
                    'Uranus' :(xoueclip,youeclip,zoueclip),
                    'Neptune':(xpoeclip,ypoeclip,zpoeclip),
                    'Pluto'  :(x_pl,y_pl,z_pl),
                    'Ceres'  :(xceeclip,yceeclip,zceeclip),
                    'Chiron' :(xcheclip,ycheclip,zcheclip),
                    'Eris'   :(xpeeclip,ypeeclip,zpeeclip)
}
from .functions import sun2planet, spherical2rectangular, ecliptic2equatorial
from .functions import rectangular2spherical  
from .heliocentric import Heliocentric

class Geocentric():
    """Import date data outputs planets positions around Earth.
    
    Args:
        year (int): Year (4 digits) ex. 2020
        month (int): Month (1-12)
        day (int): Day (1-31)
        hour (int): Hour (0-23)
        minute (int): Minute (0-60)
        UT: Time Zone (deviation from UT, -12:+14), ex. for Greece (GMT + 2) 
            enter UT = 2
        dst (int): daylight saving time (0 or 1). Wheather dst is applied at 
                   given time and place
        plane: desired output format. Should be one of: ecliptic, equatorial.
               Default: ecliptic
            
    """
    
    def __init__(self, year, month, day, hour, minute, UT=0, dst=0, 
                 plane='ecliptic'):
        self.plane=plane
        self.planetoncenter = 'Earth'
        objectlist = [ "Mercury","Venus","Earth","Mars","Jupiter","Saturn"
                           ,"Uranus","Neptune","Pluto","Ceres","Chiron","Eris"]
        h = Heliocentric(year=year, month=month, day=day, hour=hour, 
                         minute=minute, UT=UT, dst=dst, view='rectangular' )
        hplanets = h.planets()
        planets=[]
        for key in objectlist:
            if key != "Earth":
               planets.append(hplanets[key])
            else:
                planets.append((h.x2, h.y2, h.z2))
        self.objectlist = objectlist
        self.planets = planets
        self.oblecl = h.oblecl

        
    def position(self):
        """Main method which returns a dictionary of geocentric positions.
        
        Returns:
            dictionary: Planet positions around earth: Each row represents a 
                        planet and each column the position of that planet.
                        
        """        
        c = self.planets[2]
        RA, Decl, r = rectangular2spherical(c[0],c[1],c[2])
        planetccentric_pos={'Sun':(RA, Decl, r)}

        for i in range(len(self.planets)):
            if i != 2:
                planetccentric_pos[self.objectlist[i]] = sun2planet(self.planets[i][0],
                                  self.planets[i][1], self.planets[i][2],
                               self.planets[2][0], self.planets[2][1], 
                               self.planets[2][2])
                
        if self.plane=='equatorial':
            v1,v2,v3=planetccentric_pos['Sun']
            vv1,vv2,vv3 = spherical2rectangular(v1,v2,v3)
            vvv1,vvv2,vvv3 = ecliptic2equatorial(vv1,vv2,vv3, self.oblecl)
            vvvv1,vvvv2,vvvv3 = rectangular2spherical(vvv1,vvv2,vvv3)
            planetccentric_pos['Sun'] = (vvvv1,vvvv2,vvvv3)
            
            for i in range(len(self.objectlist)):
                if i != 2:
                    v1,v2,v3=planetccentric_pos[self.objectlist[i]]
                    vv1,vv2,vv3 = spherical2rectangular(v1,v2,v3)
                    vvv1,vvv2,vvv3 = ecliptic2equatorial(vv1,vv2,vv3, 
                                                         self.oblecl)
                    vvvv1,vvvv2,vvvv3 = rectangular2spherical(vvv1,vvv2,vvv3)
                    planetccentric_pos[self.objectlist[i]] =(vvvv1,vvvv2,vvvv3)
                
        return planetccentric_pos
     
    def objectnames(self):
        """Names of solar system objects used. 
        
        Returns:
            list: A list of solar system objects
            
        """               
        orderedobjects= ["Sun", "Mercury","Venus","Earth","Mars","Jupiter","Saturn","Uranus",
                "Neptune","Pluto","Ceres","Chiron","Eris"]
        return( orderedobjects )    

forplot=[]
planetname=[]
for key in planetspositionsHrect:
    planetname.append(key)
    forplot.append(planetspositionsHrect[key])

plt.figure(figsize=(15,15))
ax = plt.gca()
ax.cla() 
ax.set_xlim((-33, 33))
ax.set_ylim((-33, 33))
a=0.5
ax.plot(0,0,'.', label='Sun') 
for i in range(3):
    ax.plot(forplot[i][0] , forplot[i][1] ,'.', markersize=10, label=planetname[i]) 
    if (i >1) & (i < 3):
        ax.add_artist(plt.Circle((0, 0), ((abs(forplot[i][0])**2+abs(forplot[i][1])**2)**0.5), color='r', fill=False))

def get_text_input():
    root = tk.Tk()
    entry = ttk.Entry(root)
    user_input = entry.get()
    math_input = entry.get()

S=-0.57
R1=1
R2=1

def sun_declination(day_of_year, axial_tilt_deg=23.44, days_in_year=365.24):
    epsilon = np.deg2rad(axial_tilt_deg)
    declination = np.degrees(np.arcsin(np.sin(epsilon) * np.cos(np.deg2rad((360 / days_in_year) * (day_of_year + 10)))))
    v=90-declination
    print("It costs", 5.60*float(math_input), "USD")
    if user_input.islower() in group:
        if user_input.islower() == 'venus':
            t = np.linspace(0,2*np.pi,30)
            x=((3.08256083746)*np.sin(v))+(S*np.cosh(t)*np.cos(31))-(R1*np.sinh(t)*np.sin(31))+(S*np.cosh(t)*np.sin(31))+(R1*np.sinh(t)*np.cos(31))
            y=((3.08256083746)*np.cos(v))+(R2*np.cosh(t)*np.cos(31))-(S*np.sinh(t)*np.sin(31))+(R2*np.cosh(t)*sin(31))+(S*sinh(t)*cos(31))
            plt.plot(x,y)
            plt.show()
        
            
        if user_input.islower() == 'mars':
            t = np.linspace(0,2*np.pi,30)
            x=((3.08256083746)*np.sin(v))+(S*np.cosh(-t)*np.cos(35))-(R1*np.sinh(-t)*np.sin(35))+(S*np.cosh(-t)*np.sin(35))+(R1*np.sinh(-t)*np.cos(35))
            y=((3.08256083746)*np.cos(v))+(R2*np.cosh(-t)*np.cos(35))-(S*np.sinh(-t)*np.sin(35))+(R2*np.cosh(-t)*sin(35))+(S*sinh(-t)*cos(35))
            plt.plot(x,y)
            plt.show()                                                                          
                                                                                    
        

ax.legend()
plt.show()



